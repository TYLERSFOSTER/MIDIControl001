
# Voice Modes Design Document (Phase III — B3)

**Project:** MIDIControl001  
**Author:** Autogenerated  
**Purpose:** Formal definition of Voice Modes architecture and extensibility

---

# I. WHY THIS DOCUMENT EXISTS

This design document creates the **formal architectural contract** for multi-mode synthesis in MIDIControl001:

- How voice modes are defined  
- How they are selected  
- How VoiceManager instantiates correct voices  
- How DSP remains isolated  
- How tests for new modes must be written  
- How VoiceLET (relativistic Doppler) fits into the system  

This avoids the architectural confusion that caused failures in earlier phases.

---

# II. DEFINING “VOICE MODES”

Voice modes are **global synthesis architectures**, selected by a single integer choice:

```
voiceMode ∈ {0, 1, 2, ...}
```

We will make these explicit:

```
enum class VoiceMode {
    VoiceA = 0,
    VoiceB = 1,
    VoiceLET = 2
};
```

Modes must be:

- Switchable on a per-block basis  
- Stable for all active voices  
- Fully isolated in DSP behavior  
- Not dependent on UI  
- Deterministic  

---

# III. MODES DEFINED

## A. VoiceA (mode = 0)

### Purpose:
Baseline polyphonic subtractive voice with:

- Sine oscillator (OscillatorA)
- Simple ADSR (EnvelopeA)
- Persistent detune (CC5)
- Per-voice updateParams()
- Basic handling for CC3/4/5

### Behavior:
VoiceA defines the *canonical correctness behavior* for tests.

### Must remain stable:
Any deviation breaks regression tests.

---

## B. VoiceB (mode = 1)

### Purpose:
Alternate subtractive voice type.  
May differentiate in:

- Envelope shape  
- Oscillator type  
- Detune handling  
- Timbre options  
- Mod routing  

### Architectural Rules:
- Must inherit from BaseVoice  
- Must not modify VoiceA  
- Must be pluggable via VoiceManager based on mode_  
- Must expose updateParams()  
- Must integrate with CC mapping but can override its mapping  
- Must pass its own test suite  
- Must not break any VoiceA invariants  

### DSP Requirements (suggested):
- New oscillator: maybe saw + LPF  
- New envelope: ADSR with curvature  
- Optional: LFO  

### Instantiation:
VoiceManager must instantiate VoiceB only when mode=1.

---

## C. VoiceLET (mode = 2)

### Purpose:
Relativistic/Lorentz-ether-themed source with:

- Moving listener or emitter  
- Retarded-time calculation  
- Doppler shift  
- Possible Lorentz gamma factor in time evolution  
- Continuous frequency modulation based on relative motion  

### DSP Requirements:
- Time retardation: t' = t - r(t') / c  
- Doppler: f_observed = f_source * γ (1 - v/c) / sqrt(1 - v²/c²)
- Possibly multi-voice interference from moving “emitters”  
- Phase propagation across blocks  

### Architectural Requirements:
- Must remain completely optional  
- Must never interfere with VoiceA or VoiceB  
- Must be testable with small blocks  
- Must have explicit parameter set in ParameterSnapshot  
- Must be handled by VoiceManager’s mode switch hook  

### Additional Parameters Needed:
VoiceLET will require:

- listenerVelocity  
- emitterVelocity  
- propagationMode  
- dopplerModel type  
- maybe relativistic toggles  

These must be added cleanly:
- APVTS
- Snapshot
- Tests
- DSP layers  

---

# IV. MODE SWITCHING ARCHITECTURE

## A. PluginProcessor

- Reads raw APVTS int mode  
- Stores in snapshot.voiceMode  
- Sends snapshot.voiceMode to VoiceManager

## B. VoiceManager (main switch point)

Add:

```
void applyModeConfiguration();
```

Called every block inside startBlock().

```
void VoiceManager::applyModeConfiguration() {
    switch (mode_) {
        case VoiceMode::VoiceA:
            ensureAllVoicesAre<VoiceA>();
            break;

        case VoiceMode::VoiceB:
            ensureAllVoicesAre<VoiceB>();
            break;

        case VoiceMode::VoiceLET:
            ensureAllVoicesAre<VoiceLET>();
            break;

        default:
            // clamp to safe default
            mode_ = VoiceMode::VoiceA;
            ensureAllVoicesAre<VoiceA>();
            break;
    }
}
```

### Key Point:
ensureAllVoicesAre<T>() must:

- Not destroy active voices unless mode changes  
- Rebuild the voice array only when needed  
- Preserve polyphony semantics

---

# V. PARAMETER STRATEGY

VoiceA parameters:  
Already exist in Snapshot.

VoiceB parameters:  
Should reuse envAttack/envRelease unless overridden.

VoiceLET parameters:  
Must be new snapshot fields — not a mixture with VoiceA.

---

# VI. TESTING REQUIREMENTS

For each new mode (B1, B2, B3):

### Required tests:

1. **Parameter existence**
2. **Snapshot propagation**
3. **Processor-level stability**
4. **VoiceManager correct instantiation**
5. **DSP correctness**
6. **No regressions in VoiceA**

VoiceLET must have analytic Doppler tests at:

- 0 velocity  
- small velocity  
- relativistic velocity (v → c)

---

# VII. FUTURE STRUCTURE (RECOMMENDED)

```
Source/dsp/
    VoiceModes.h
    VoiceManager.{h,cpp}
    voices/
        VoiceA.{h,cpp}
        VoiceB.{h,cpp}
        VoiceLET.{h,cpp}
```

---

# VIII. SUMMARY

This design doc defines:

- Exact meaning of voice modes  
- Responsibilities of VoiceManager  
- Contract for VoiceA, VoiceB, VoiceLET  
- DSP expectations for Doppler  
- Structural isolation of each voice class  
- Test requirements  
- Future scalability rules  

Nothing in this document changes DSP code.  
It defines the **blueprint** for Phase III.

